package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"

	"github.com/captain-corgi/go-graphql-example/internal/application/user"
	"github.com/captain-corgi/go-graphql-example/internal/interfaces/graphql/generated"
	"github.com/captain-corgi/go-graphql-example/internal/interfaces/graphql/model"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.CreateUserPayload, error) {
	// Log operation start
	r.logOperation(ctx, "CreateUser", map[string]interface{}{
		"email": input.Email,
		"name":  input.Name,
	})

	// Validate and sanitize input
	sanitizedInput := model.CreateUserInput{
		Email: sanitizeString(input.Email),
		Name:  sanitizeString(input.Name),
	}

	if err := r.validateInput(ctx, "CreateUser", func() error {
		return validateCreateUserInput(sanitizedInput)
	}); err != nil {
		return &model.CreateUserPayload{
			Errors: []*model.Error{mapErrorDTOToGraphQL(user.ErrorDTO{
				Message: err.Error(),
				Code:    "VALIDATION_ERROR",
			})},
		}, nil
	}

	// Call application service
	req := mapCreateUserInputToRequest(sanitizedInput)
	resp, err := r.userService.CreateUser(ctx, req)
	if err != nil {
		return &model.CreateUserPayload{
			Errors: []*model.Error{mapErrorDTOToGraphQL(user.ErrorDTO{
				Message: "Failed to create user",
				Code:    "INTERNAL_ERROR",
			})},
		}, nil
	}

	// Handle application-level errors
	if len(resp.Errors) > 0 {
		return &model.CreateUserPayload{
			Errors: mapErrorDTOsToGraphQL(resp.Errors),
		}, nil
	}

	// Map successful result
	result := &model.CreateUserPayload{
		User: mapUserDTOToGraphQL(resp.User),
	}

	r.logOperationSuccess(ctx, "CreateUser", result)
	return result, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.UpdateUserPayload, error) {
	// Log operation start
	r.logOperation(ctx, "UpdateUser", map[string]interface{}{
		"id":    id,
		"email": input.Email,
		"name":  input.Name,
	})

	// Validate and sanitize input
	sanitizedID := sanitizeString(id)
	sanitizedInput := model.UpdateUserInput{
		Email: sanitizeStringPointer(input.Email),
		Name:  sanitizeStringPointer(input.Name),
	}

	// Validate user ID
	if err := r.validateInput(ctx, "UpdateUser", func() error {
		return validateUserID(sanitizedID)
	}); err != nil {
		return &model.UpdateUserPayload{
			Errors: []*model.Error{mapErrorDTOToGraphQL(user.ErrorDTO{
				Message: err.Error(),
				Code:    "VALIDATION_ERROR",
			})},
		}, nil
	}

	// Validate update input
	if err := r.validateInput(ctx, "UpdateUser", func() error {
		return validateUpdateUserInput(sanitizedInput)
	}); err != nil {
		return &model.UpdateUserPayload{
			Errors: []*model.Error{mapErrorDTOToGraphQL(user.ErrorDTO{
				Message: err.Error(),
				Code:    "VALIDATION_ERROR",
			})},
		}, nil
	}

	// Call application service
	req := mapUpdateUserInputToRequest(sanitizedID, sanitizedInput)
	resp, err := r.userService.UpdateUser(ctx, req)
	if err != nil {
		return &model.UpdateUserPayload{
			Errors: []*model.Error{mapErrorDTOToGraphQL(user.ErrorDTO{
				Message: "Failed to update user",
				Code:    "INTERNAL_ERROR",
			})},
		}, nil
	}

	// Handle application-level errors
	if len(resp.Errors) > 0 {
		return &model.UpdateUserPayload{
			Errors: mapErrorDTOsToGraphQL(resp.Errors),
		}, nil
	}

	// Map successful result
	result := &model.UpdateUserPayload{
		User: mapUserDTOToGraphQL(resp.User),
	}

	r.logOperationSuccess(ctx, "UpdateUser", result)
	return result, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.DeleteUserPayload, error) {
	// Log operation start
	r.logOperation(ctx, "DeleteUser", map[string]interface{}{
		"id": id,
	})

	// Validate and sanitize input
	sanitizedID := sanitizeString(id)
	if err := r.validateInput(ctx, "DeleteUser", func() error {
		return validateUserID(sanitizedID)
	}); err != nil {
		return &model.DeleteUserPayload{
			Success: false,
			Errors: []*model.Error{mapErrorDTOToGraphQL(user.ErrorDTO{
				Message: err.Error(),
				Code:    "VALIDATION_ERROR",
			})},
		}, nil
	}

	// Call application service
	req := user.DeleteUserRequest{ID: sanitizedID}
	resp, err := r.userService.DeleteUser(ctx, req)
	if err != nil {
		return &model.DeleteUserPayload{
			Success: false,
			Errors: []*model.Error{mapErrorDTOToGraphQL(user.ErrorDTO{
				Message: "Failed to delete user",
				Code:    "INTERNAL_ERROR",
			})},
		}, nil
	}

	// Handle application-level errors
	if len(resp.Errors) > 0 {
		return &model.DeleteUserPayload{
			Success: false,
			Errors:  mapErrorDTOsToGraphQL(resp.Errors),
		}, nil
	}

	// Map successful result
	result := &model.DeleteUserPayload{
		Success: resp.Success,
	}

	r.logOperationSuccess(ctx, "DeleteUser", result)
	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
