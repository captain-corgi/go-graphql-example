package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"

	"github.com/captain-corgi/go-graphql-example/internal/application/user"
	"github.com/captain-corgi/go-graphql-example/internal/domain/errors"
	"github.com/captain-corgi/go-graphql-example/internal/interfaces/graphql/generated"
	"github.com/captain-corgi/go-graphql-example/internal/interfaces/graphql/model"
)

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Log operation start
	r.logOperation(ctx, "User", map[string]interface{}{
		"id": id,
	})

	// Validate and sanitize input
	sanitizedID := sanitizeString(id)
	if err := r.validateInput(ctx, "User", func() error {
		return validateUserID(sanitizedID)
	}); err != nil {
		return nil, err
	}

	// Call application service
	req := user.GetUserRequest{ID: sanitizedID}
	resp, err := r.userService.GetUser(ctx, req)
	if err != nil {
		return nil, r.handleGraphQLError(ctx, err, "User")
	}

	// Handle application-level errors
	if len(resp.Errors) > 0 {
		// Return the first error as GraphQL error
		firstError := resp.Errors[0]
		domainErr := errors.DomainError{
			Code:    firstError.Code,
			Message: firstError.Message,
			Field:   firstError.Field,
		}
		return nil, r.handleGraphQLError(ctx, domainErr, "User")
	}

	// Map result to GraphQL model
	result := mapUserDTOToGraphQL(resp.User)
	r.logOperationSuccess(ctx, "User", result)

	return result, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, first *int, after *string) (*model.UserConnection, error) {
	// Log operation start
	r.logOperation(ctx, "Users", map[string]interface{}{
		"first": first,
		"after": after,
	})

	// Validate pagination parameters
	if err := r.validateInput(ctx, "Users", func() error {
		return validatePaginationParams(first, after)
	}); err != nil {
		return nil, err
	}

	// Sanitize after parameter
	var sanitizedAfter string
	if after != nil {
		sanitizedAfter = sanitizeString(*after)
	}

	// Set default first value
	firstValue := 10 // Default page size
	if first != nil {
		firstValue = *first
	}

	// Call application service
	req := user.ListUsersRequest{
		First: firstValue,
		After: sanitizedAfter,
	}
	resp, err := r.userService.ListUsers(ctx, req)
	if err != nil {
		return nil, r.handleGraphQLError(ctx, err, "Users")
	}

	// Handle application-level errors
	if len(resp.Errors) > 0 {
		// Return the first error as GraphQL error
		firstError := resp.Errors[0]
		domainErr := errors.DomainError{
			Code:    firstError.Code,
			Message: firstError.Message,
			Field:   firstError.Field,
		}
		return nil, r.handleGraphQLError(ctx, domainErr, "Users")
	}

	// Map result to GraphQL model
	result := mapUserConnectionDTOToGraphQL(resp.Users)
	r.logOperationSuccess(ctx, "Users", result)

	return result, nil
}



// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
