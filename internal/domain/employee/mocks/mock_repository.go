// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	employee "github.com/captain-corgi/go-graphql-example/internal/domain/employee"
	user "github.com/captain-corgi/go-graphql-example/internal/domain/user"
	gomock "github.com/golang/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockRepository) Count(ctx context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockRepositoryMockRecorder) Count(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockRepository)(nil).Count), ctx)
}

// CountByDepartment mocks base method.
func (m *MockRepository) CountByDepartment(ctx context.Context, department employee.Department) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountByDepartment", ctx, department)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountByDepartment indicates an expected call of CountByDepartment.
func (mr *MockRepositoryMockRecorder) CountByDepartment(ctx, department interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountByDepartment", reflect.TypeOf((*MockRepository)(nil).CountByDepartment), ctx, department)
}

// CountByStatus mocks base method.
func (m *MockRepository) CountByStatus(ctx context.Context, status employee.Status) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountByStatus", ctx, status)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountByStatus indicates an expected call of CountByStatus.
func (mr *MockRepositoryMockRecorder) CountByStatus(ctx, status interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountByStatus", reflect.TypeOf((*MockRepository)(nil).CountByStatus), ctx, status)
}

// Create mocks base method.
func (m *MockRepository) Create(ctx context.Context, employee *employee.Employee) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, employee)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockRepositoryMockRecorder) Create(ctx, employee interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepository)(nil).Create), ctx, employee)
}

// Delete mocks base method.
func (m *MockRepository) Delete(ctx context.Context, id employee.EmployeeID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockRepositoryMockRecorder) Delete(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockRepository)(nil).Delete), ctx, id)
}

// ExistsByEmployeeCode mocks base method.
func (m *MockRepository) ExistsByEmployeeCode(ctx context.Context, employeeCode employee.EmployeeCode) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistsByEmployeeCode", ctx, employeeCode)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExistsByEmployeeCode indicates an expected call of ExistsByEmployeeCode.
func (mr *MockRepositoryMockRecorder) ExistsByEmployeeCode(ctx, employeeCode interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistsByEmployeeCode", reflect.TypeOf((*MockRepository)(nil).ExistsByEmployeeCode), ctx, employeeCode)
}

// ExistsByUserID mocks base method.
func (m *MockRepository) ExistsByUserID(ctx context.Context, userID user.UserID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistsByUserID", ctx, userID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExistsByUserID indicates an expected call of ExistsByUserID.
func (mr *MockRepositoryMockRecorder) ExistsByUserID(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistsByUserID", reflect.TypeOf((*MockRepository)(nil).ExistsByUserID), ctx, userID)
}

// FindAll mocks base method.
func (m *MockRepository) FindAll(ctx context.Context, limit int, cursor string) ([]*employee.Employee, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAll", ctx, limit, cursor)
	ret0, _ := ret[0].([]*employee.Employee)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindAll indicates an expected call of FindAll.
func (mr *MockRepositoryMockRecorder) FindAll(ctx, limit, cursor interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockRepository)(nil).FindAll), ctx, limit, cursor)
}

// FindByDepartment mocks base method.
func (m *MockRepository) FindByDepartment(ctx context.Context, department employee.Department, limit int, cursor string) ([]*employee.Employee, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByDepartment", ctx, department, limit, cursor)
	ret0, _ := ret[0].([]*employee.Employee)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindByDepartment indicates an expected call of FindByDepartment.
func (mr *MockRepositoryMockRecorder) FindByDepartment(ctx, department, limit, cursor interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByDepartment", reflect.TypeOf((*MockRepository)(nil).FindByDepartment), ctx, department, limit, cursor)
}

// FindByEmployeeCode mocks base method.
func (m *MockRepository) FindByEmployeeCode(ctx context.Context, employeeCode employee.EmployeeCode) (*employee.Employee, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByEmployeeCode", ctx, employeeCode)
	ret0, _ := ret[0].(*employee.Employee)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByEmployeeCode indicates an expected call of FindByEmployeeCode.
func (mr *MockRepositoryMockRecorder) FindByEmployeeCode(ctx, employeeCode interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEmployeeCode", reflect.TypeOf((*MockRepository)(nil).FindByEmployeeCode), ctx, employeeCode)
}

// FindByID mocks base method.
func (m *MockRepository) FindByID(ctx context.Context, id employee.EmployeeID) (*employee.Employee, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", ctx, id)
	ret0, _ := ret[0].(*employee.Employee)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockRepositoryMockRecorder) FindByID(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockRepository)(nil).FindByID), ctx, id)
}

// FindByStatus mocks base method.
func (m *MockRepository) FindByStatus(ctx context.Context, status employee.Status, limit int, cursor string) ([]*employee.Employee, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByStatus", ctx, status, limit, cursor)
	ret0, _ := ret[0].([]*employee.Employee)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindByStatus indicates an expected call of FindByStatus.
func (mr *MockRepositoryMockRecorder) FindByStatus(ctx, status, limit, cursor interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByStatus", reflect.TypeOf((*MockRepository)(nil).FindByStatus), ctx, status, limit, cursor)
}

// FindByUserID mocks base method.
func (m *MockRepository) FindByUserID(ctx context.Context, userID user.UserID) (*employee.Employee, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserID", ctx, userID)
	ret0, _ := ret[0].(*employee.Employee)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByUserID indicates an expected call of FindByUserID.
func (mr *MockRepositoryMockRecorder) FindByUserID(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserID", reflect.TypeOf((*MockRepository)(nil).FindByUserID), ctx, userID)
}

// Update mocks base method.
func (m *MockRepository) Update(ctx context.Context, employee *employee.Employee) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, employee)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockRepositoryMockRecorder) Update(ctx, employee interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRepository)(nil).Update), ctx, employee)
}
